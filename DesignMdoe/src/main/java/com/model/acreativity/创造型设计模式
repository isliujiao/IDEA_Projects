creativity：创造型模式
    1、Factory：单例工厂
        1.首先创建一个接口"Shape"
        2.创建接口的实现类：Circle、Rectangle、Square
        3.创建工厂"ShapeFactory"，生成基于给定信息的实体类的对象。
        4.使用该工厂，通过传递类型信息来获取实体类的对象。"FactoryPatternDemo"
            定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟
        到子类进行。是用`工厂方法`代替`new操作`的一种模式（即根据传来的参数，来确定new的对象）
        意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
        何时使用：我们明确地计划不同条件下创建不同实例时。

    2、AbstractFactoryPattern：抽象工厂
        1.首先创建一个接口"Shape"
        2.创建接口的实现类：Circle、Rectangle、Square
        3.创建一个接口"Color"
        4.创建接口的实现类：Red、Green、Blue
        5.为 Color 和 Shape 对象创建抽象类来获取工厂"AbstractFactory"
        6.创建扩展了 AbstractFactory 的工厂类"ShapeFactory"、"ColorFactory"，基于给定的信息生成实体类的对象。
        7.创建一个工厂创造器/生成器类"FactoryProducer"，通过传递形状或颜色信息来获取工厂
        8.使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象"AbstractFactoryPatternDemo"
            提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
        围绕一个‘超级工厂’创建其他工厂。该超级工厂又称为其他工厂的工厂
        意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
        何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

    3、Singleton：单例设计模式
        1、单例类只能有一个实例。
        2、单例类必须自己创建自己的唯一实例。
        3、单例类必须给所有其他对象提供这一实例。
            单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。
            懒汉式：在真正需要使用对象时才去创建该单例类对象
            饿汉式：在类加载的时候进行实例化，等待被程序使用（new）
        意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
        何时使用：当您想控制实例数目，节省系统资源的时候。

    4、BuilderPattern：建造者模式
        将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。
        1、Server：Item-属性、Packing-包装类型
        2、Impl：Bottle-瓶子、Wrapper-包装纸
        3、abs：Burger-汉堡属性、ColdDrink-冷饮属性
        4、goods：ChickenBurger-鸡肉汉堡包、Coke-可口可乐、Pepsi-百事可乐、VegBurger-蔬菜汉堡
        5、hander：Meal-进餐、MealBuilder-创建对象
        - 何时使用：一些基本部件不会变，而其组合经常变化的时候。
        - 优点： 1、建造者独立，易扩展。 2、便于控制细节风险。
        - 缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。

    5、Prototype Pattern：原型模式
        用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
        1、Shape - 形状抽象类并实现Cloneable
        2、Rectangle-矩形、Square-正方形、Circle-圆形 继承`形状抽象类`并实现抽象方法
        3、从数据库获取实体类，并把它们存储在一个 Hashtable 中。
        4、使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆。
        - 何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。
                    2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。
                    3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。
        - 优点： 1、性能提高。 2、逃避构造函数的约束。
        - 缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，
        但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。
                 2、必须实现 Cloneable 接口。